import fs from 'fs';
import path from 'path';

const schemaPath = path.join(__dirname, '../prisma/schema.prisma');
const outputPath = path.join(__dirname, '../../src/types/schema.ts');

const typeMapping: Record<string, string> = {
    'Int': 'number',
    'String': 'string',
    'Boolean': 'boolean',
    'DateTime': 'string', // JSON serializes Date to string
    'Float': 'number',
    'Decimal': 'number',
    'Json': 'any'
};

function generateTypes() {
    try {
        const schemaContent = fs.readFileSync(schemaPath, 'utf-8');
        const lines = schemaContent.split('\n');

        let output = `// \n// AUTO-GENERATED FILE. DO NOT MODIFY.\n// This file was generated by server/scripts/generate-types.ts\n// \n\n`;

        let currentModel = '';
        let isInsideModel = false;

        for (const line of lines) {
            const trimmed = line.trim();

            if (trimmed.startsWith('model ')) {
                const modelName = trimmed.split(/\s+/)[1];
                currentModel = modelName;
                isInsideModel = true;
                output += `export interface ${modelName} {\n`;
                continue;
            }

            if (trimmed === '}') {
                if (isInsideModel) {
                    output += '}\n\n';
                    isInsideModel = false;
                }
                continue;
            }

            if (isInsideModel && trimmed && !trimmed.startsWith('//') && !trimmed.startsWith('@@')) {
                const parts = trimmed.split(/\s+/);
                // Handle field name and type (ignoring attributes like @id, @default, etc.)
                // Example: id Int @id @default(autoincrement())
                // Example: name String?

                if (parts.length >= 2) {
                    let fieldName = parts[0];
                    let prismaType = parts[1];
                    let isOptional = false;

                    if (prismaType.endsWith('?')) {
                        isOptional = true;
                        prismaType = prismaType.slice(0, -1);
                    }

                    // Remove array brackets if present (e.g., Post[])
                    let isArray = false;
                    if (prismaType.endsWith('[]')) {
                        isArray = true;
                        prismaType = prismaType.slice(0, -2);
                    }

                    const tsType = typeMapping[prismaType] || 'any'; // Default to any for relations or unknown types

                    output += `    ${fieldName}${isOptional ? '?' : ''}: ${tsType}${isArray ? '[]' : ''};\n`;
                }
            }
        }

        // Ensure directory exists
        const dir = path.dirname(outputPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(outputPath, output);
        console.log(`Types generated successfully at ${outputPath}`);

    } catch (error) {
        console.error('Error generating types:', error);
        process.exit(1);
    }
}

generateTypes();
